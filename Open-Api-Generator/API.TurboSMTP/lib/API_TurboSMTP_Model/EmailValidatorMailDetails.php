<?php
/**
 * EmailValidatorMailDetails
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  API_TurboSMTP_Invoker
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * TurboSMTP Public APIs
 *
 * This document describes all public turboSMTP **V2** API and offers endpoints Descriptions, Parameters, Requests, Responses and Samples of usage.  [Click here to view the previous version of turboSMTP Public API Version 1.0](https://www.serversmtp.com/turbo-api-1)   # Security For the most part (and where not otherwise explicit) turboSMTP’s API requires Authorization.   Authorization to access a user’s resource is granted to clients provided they set  authentication headers into their request, valued with the proper values issued by turboSMTP servers.  ## *  Authorization via ConsumerKey/ConsumerSecret  This type of authorization consists of a pair of headers, named consumerKey and consumerSecret that are created and granted to the end user to be used in a permanent way (unless they´re deleted of course). This kind of authentication is intended to provide access to endpoints features without the need of providing the user the account details (email address + password).  *consumerKey:* Consumer Key Granted.  *consumerSecret:* Consumer Secret Granted.  (Use [/consumerKeys/create](#/consumerkey/createConsumerKey) create a consumer key/secret pair).      ## *  Authorization via Authentication Key  The authentication key is user-based and it is issued by turboSMTP servers upon successful user’s email address + password challenge, performed by means of appropriate request.      *Authorization:* Authorization_Key  (Use [/authentication/authorize](#/authentication/AuthenticationLogin) to obtain an API Key)  # Data Interchange Format  For the most part (and where not otherwise explicit) turboSMTP’s API uses JSON as the data format of choice when it comes to request and response bodies.
 *
 * The version of the OpenAPI document: 2.0.0-oas3
 * Contact: api@turbo-smtp.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.3.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace API_TurboSMTP_Invoker\API_TurboSMTP_Model;

use \ArrayAccess;
use \API_TurboSMTP_Invoker\ObjectSerializer;

/**
 * EmailValidatorMailDetails Class Doc Comment
 *
 * @category Class
 * @package  API_TurboSMTP_Invoker
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class EmailValidatorMailDetails implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'EmailValidatorMailDetails';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'email' => 'string',
        'status' => 'string',
        'sub_status' => 'string',
        'free_email' => 'bool',
        'domain' => 'string',
        'domain_age_days' => 'int',
        'smtp_provider' => 'string',
        'mx_found' => 'bool',
        'mx_record' => 'string',
        'did_you_mean' => 'string',
        'account' => 'string',
        'firstname' => 'string',
        'lastname' => 'string',
        'gender' => 'string',
        'country' => 'string',
        'region' => 'string',
        'city' => 'string',
        'zipcode' => 'int',
        'processed_at' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'email' => 'email',
        'status' => null,
        'sub_status' => null,
        'free_email' => null,
        'domain' => null,
        'domain_age_days' => null,
        'smtp_provider' => null,
        'mx_found' => null,
        'mx_record' => null,
        'did_you_mean' => null,
        'account' => null,
        'firstname' => null,
        'lastname' => null,
        'gender' => null,
        'country' => null,
        'region' => null,
        'city' => null,
        'zipcode' => null,
        'processed_at' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'email' => false,
        'status' => false,
        'sub_status' => false,
        'free_email' => false,
        'domain' => false,
        'domain_age_days' => true,
        'smtp_provider' => true,
        'mx_found' => false,
        'mx_record' => false,
        'did_you_mean' => false,
        'account' => false,
        'firstname' => true,
        'lastname' => true,
        'gender' => true,
        'country' => true,
        'region' => true,
        'city' => true,
        'zipcode' => true,
        'processed_at' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'email' => 'email',
        'status' => 'status',
        'sub_status' => 'sub_status',
        'free_email' => 'free_email',
        'domain' => 'domain',
        'domain_age_days' => 'domain_age_days',
        'smtp_provider' => 'smtp_provider',
        'mx_found' => 'mx_found',
        'mx_record' => 'mx_record',
        'did_you_mean' => 'did_you_mean',
        'account' => 'account',
        'firstname' => 'firstname',
        'lastname' => 'lastname',
        'gender' => 'gender',
        'country' => 'country',
        'region' => 'region',
        'city' => 'city',
        'zipcode' => 'zipcode',
        'processed_at' => 'processed_at'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'email' => 'setEmail',
        'status' => 'setStatus',
        'sub_status' => 'setSubStatus',
        'free_email' => 'setFreeEmail',
        'domain' => 'setDomain',
        'domain_age_days' => 'setDomainAgeDays',
        'smtp_provider' => 'setSmtpProvider',
        'mx_found' => 'setMxFound',
        'mx_record' => 'setMxRecord',
        'did_you_mean' => 'setDidYouMean',
        'account' => 'setAccount',
        'firstname' => 'setFirstname',
        'lastname' => 'setLastname',
        'gender' => 'setGender',
        'country' => 'setCountry',
        'region' => 'setRegion',
        'city' => 'setCity',
        'zipcode' => 'setZipcode',
        'processed_at' => 'setProcessedAt'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'email' => 'getEmail',
        'status' => 'getStatus',
        'sub_status' => 'getSubStatus',
        'free_email' => 'getFreeEmail',
        'domain' => 'getDomain',
        'domain_age_days' => 'getDomainAgeDays',
        'smtp_provider' => 'getSmtpProvider',
        'mx_found' => 'getMxFound',
        'mx_record' => 'getMxRecord',
        'did_you_mean' => 'getDidYouMean',
        'account' => 'getAccount',
        'firstname' => 'getFirstname',
        'lastname' => 'getLastname',
        'gender' => 'getGender',
        'country' => 'getCountry',
        'region' => 'getRegion',
        'city' => 'getCity',
        'zipcode' => 'getZipcode',
        'processed_at' => 'getProcessedAt'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const STATUS_VALID = 'valid';
    public const STATUS_INVALID = 'invalid';
    public const STATUS_CATCH_ALL = 'catch-all';
    public const STATUS_UNKNOWN = 'unknown';
    public const STATUS_SPAMTRAP = 'spamtrap';
    public const STATUS_ABUSE = 'abuse';
    public const STATUS_DO_NOT_MAIL = 'do_not_mail';
    public const SUB_STATUS_EMPTY = '';
    public const SUB_STATUS_ANTISPAM_SYSTEM = 'antispam_system';
    public const SUB_STATUS_GREYLISTED = 'greylisted';
    public const SUB_STATUS_MAIL_SERVER_TEMPORARY_ERROR = 'mail_server_temporary_error';
    public const SUB_STATUS_FORCIBLE_DISCONNECT = 'forcible_disconnect';
    public const SUB_STATUS_MAIL_SERVER_DID_NOT_RESPOND = 'mail_server_did_not_respond';
    public const SUB_STATUS_TIMEOUT_EXCEEDED = 'timeout_exceeded';
    public const SUB_STATUS_FAILED_SMTP_CONNECTION = 'failed_smtp_connection';
    public const SUB_STATUS_MAILBOX_QUOTA_EXCEEDED = 'mailbox_quota_exceeded';
    public const SUB_STATUS_EXCEPTION_OCCURRED = 'exception_occurred';
    public const SUB_STATUS_POSSIBLE_TRAP = 'possible_trap';
    public const SUB_STATUS_ROLE_BASED = 'role_based';
    public const SUB_STATUS_GLOBAL_SUPPRESSION = 'global_suppression';
    public const SUB_STATUS_MAILBOX_NOT_FOUND = 'mailbox_not_found';
    public const SUB_STATUS_NO_DNS_ENTRIES = 'no_dns_entries';
    public const SUB_STATUS_FAILED_SYNTAX_CHECK = 'failed_syntax_check';
    public const SUB_STATUS_POSSIBLE_TYPO = 'possible_typo';
    public const SUB_STATUS_UNROUTABLE_IP_ADDRESS = 'unroutable_ip_address';
    public const SUB_STATUS_LEADING_PERIOD_REMOVED = 'leading_period_removed';
    public const SUB_STATUS_DOES_NOT_ACCEPT_MAIL = 'does_not_accept_mail';
    public const SUB_STATUS_ALIAS_ADDRESS = 'alias_address';
    public const SUB_STATUS_ROLE_BASED_CATCH_ALL = 'role_based_catch_all';
    public const SUB_STATUS_DISPOSABLE = 'disposable';
    public const SUB_STATUS_TOXIC = 'toxic';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_VALID,
            self::STATUS_INVALID,
            self::STATUS_CATCH_ALL,
            self::STATUS_UNKNOWN,
            self::STATUS_SPAMTRAP,
            self::STATUS_ABUSE,
            self::STATUS_DO_NOT_MAIL,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSubStatusAllowableValues()
    {
        return [
            self::SUB_STATUS_EMPTY,
            self::SUB_STATUS_ANTISPAM_SYSTEM,
            self::SUB_STATUS_GREYLISTED,
            self::SUB_STATUS_MAIL_SERVER_TEMPORARY_ERROR,
            self::SUB_STATUS_FORCIBLE_DISCONNECT,
            self::SUB_STATUS_MAIL_SERVER_DID_NOT_RESPOND,
            self::SUB_STATUS_TIMEOUT_EXCEEDED,
            self::SUB_STATUS_FAILED_SMTP_CONNECTION,
            self::SUB_STATUS_MAILBOX_QUOTA_EXCEEDED,
            self::SUB_STATUS_EXCEPTION_OCCURRED,
            self::SUB_STATUS_POSSIBLE_TRAP,
            self::SUB_STATUS_ROLE_BASED,
            self::SUB_STATUS_GLOBAL_SUPPRESSION,
            self::SUB_STATUS_MAILBOX_NOT_FOUND,
            self::SUB_STATUS_NO_DNS_ENTRIES,
            self::SUB_STATUS_FAILED_SYNTAX_CHECK,
            self::SUB_STATUS_POSSIBLE_TYPO,
            self::SUB_STATUS_UNROUTABLE_IP_ADDRESS,
            self::SUB_STATUS_LEADING_PERIOD_REMOVED,
            self::SUB_STATUS_DOES_NOT_ACCEPT_MAIL,
            self::SUB_STATUS_ALIAS_ADDRESS,
            self::SUB_STATUS_ROLE_BASED_CATCH_ALL,
            self::SUB_STATUS_DISPOSABLE,
            self::SUB_STATUS_TOXIC,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('email', $data ?? [], null);
        $this->setIfExists('status', $data ?? [], null);
        $this->setIfExists('sub_status', $data ?? [], null);
        $this->setIfExists('free_email', $data ?? [], null);
        $this->setIfExists('domain', $data ?? [], null);
        $this->setIfExists('domain_age_days', $data ?? [], null);
        $this->setIfExists('smtp_provider', $data ?? [], null);
        $this->setIfExists('mx_found', $data ?? [], null);
        $this->setIfExists('mx_record', $data ?? [], null);
        $this->setIfExists('did_you_mean', $data ?? [], null);
        $this->setIfExists('account', $data ?? [], null);
        $this->setIfExists('firstname', $data ?? [], null);
        $this->setIfExists('lastname', $data ?? [], null);
        $this->setIfExists('gender', $data ?? [], null);
        $this->setIfExists('country', $data ?? [], null);
        $this->setIfExists('region', $data ?? [], null);
        $this->setIfExists('city', $data ?? [], null);
        $this->setIfExists('zipcode', $data ?? [], null);
        $this->setIfExists('processed_at', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['email'] === null) {
            $invalidProperties[] = "'email' can't be null";
        }
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'status', must be one of '%s'",
                $this->container['status'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSubStatusAllowableValues();
        if (!is_null($this->container['sub_status']) && !in_array($this->container['sub_status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'sub_status', must be one of '%s'",
                $this->container['sub_status'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['processed_at']) && !preg_match("/(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})/", $this->container['processed_at'])) {
            $invalidProperties[] = "invalid value for 'processed_at', must be conform to the pattern /(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})/.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets email
     *
     * @return string
     */
    public function getEmail()
    {
        return $this->container['email'];
    }

    /**
     * Sets email
     *
     * @param string $email email
     *
     * @return self
     */
    public function setEmail($email)
    {
        if (is_null($email)) {
            throw new \InvalidArgumentException('non-nullable email cannot be null');
        }
        $this->container['email'] = $email;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string|null
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string|null $status The status of the email address you are validating.    DELIVERABILITY STATUS EXPLANATION    valid:   These are emails that were determined to be valid and safe to email to, they will have a very low bounce rate of under 2%. If you receive bounces it can be because your IP might be blacklisted where our IP was not. Sometimes the email accounts exist, but they are only accepting mail from people in their contact lists. Sometimes you will get throttle on number of emails you can send to a specific domain per hour. It's important to look at the SMTP Bounce codes to determine why.      invalid:   These are emails that were determined to be invalid, please delete them from your mailing list.      catch-all:    These emails are impossible to validate without sending a real email and waiting for a bounce. The term Catch-all means that the email server tells you that the email is valid, whether it's valid or invalid. If you want to email these addresses, we suggest you segment them into a catch-all group and be aware that some of these will most likely bounce.      spamtrap:    These emails are believed to be spamtraps and should not be mailed. We have technology in place to determine if certain emails should be classified as spamtrap. We don't know all the spamtrap email addresses, but we do know a lot of them.      abuse:    These emails belong to people who are known to click the abuse links in emails, hence abusers or complainers. We recommend not emailing these addresses.      do_not_mail:    These emails belong to companies, role-based, or people you just want to avoid emailing to. They are broken down into 6 sub-categories \"disposable\",\"toxic\", \"role_based\", \"role_based_catch_all\", \"global_suppression\" and \"possible_trap\". You should decide if you want to email these address. They are valid email addresses, but shouldn't be mailed in most cases.      unknown:    These emails we weren't able to validate for one reason or another. Typical cases are \"Their mail server was down\" or \"the anti-spam system is blocking us\". In most cases, 80% unknowns are invalid/bad email addresses.
     *
     * @return self
     */
    public function setStatus($status)
    {
        if (is_null($status)) {
            throw new \InvalidArgumentException('non-nullable status cannot be null');
        }
        $allowedValues = $this->getStatusAllowableValues();
        if (!in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'status', must be one of '%s'",
                    $status,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets sub_status
     *
     * @return string|null
     */
    public function getSubStatus()
    {
        return $this->container['sub_status'];
    }

    /**
     * Sets sub_status
     *
     * @param string|null $sub_status The sub-status of the email address you are validating.  alias_address:  (valid) These emails addresses act as forwarders/aliases and are not real inboxes, for example if you send an email to forward@example.com and then the email is forwarded to realinbox@example.com. It's a valid email address and you can send to them, it's just a little more information about the email address. We can sometimes detect alias email addresses and when we do we let you know.  antispam_system:  (unknown) These emails have anti-spam systems deployed that are preventing us from validating these emails.  does_not_accept_mail:  (invalid) These domains only send mail and don't accept incoming mail.  exception_occurred:  (unknown) These emails caused an exception when validating.  failed_smtp_connection:  (unknown) These emails belong to a mail server that won't allow an SMTP connection. Most of the time, these emails will end up being invalid.  failed_syntax_check:  (Invalid) Emails that fail RFC syntax protocols  forcible_disconnect:  (Unknown) These emails belong to a mail server that disconnects immediately upon connecting. Most of the time, these emails will end up being invalid. global_suppression:  (do_not_mail) These emails are found in many popular global suppression lists (GSL), they consist of known ISP complainers, direct complainers, purchased addresses, domains that don't send mail, and known litigators.  greylisted:  (Unknown) Emails where we are temporarily unable to validate them. A lot of times if you resubmit these emails they will validate on a second pass.  leading_period_removed:  (valid) If a valid gmail.com email address starts with a period '.' we will remove it, so the email address is compatible with all mailing systems.  mail_server_did_not_respond-  (unknown) These emails belong to a mail server that is not responding to mail commands. Most of the time, these emails will end up being invalid.  mail_server_temporary_error:  (unknown) These emails belong to a mail server that is returning a temporary error. Most of the time, these emails will end up being invalid. mailbox_quota_exceeded:  (invalid) These emails exceeded their space quota and are not accepting emails. These emails are marked invalid.  mailbox_not_found:  (invalid) These emails addresses are valid in syntax, but do not exist. These emails are marked invalid.  no_dns_entries:  (invalid) These emails are valid in syntax, but the domain doesn't have any records in DNS or have incomplete DNS Records. Therefore, mail programs will be unable to or have difficulty sending to them. These emails are marked invalid.  possible_trap:  (do_not_mail) These emails contain keywords that might correlate to possible spam traps like spam@ or @spamtrap.com. Examine these before deciding to send emails to them or not.  possible_typo:  (invalid) These are emails of commonly misspelled popular domains. These emails are marked invalid.  role_based:  (do_not_mail) These emails belong to a position or a group of people, like sales@ info@ and contact@. Role-based emails have a strong correlation to people reporting mails sent to them as spam and abuse.  role_based_catch_all:  (do_not_mail) These emails are role-based and also belong to a catch_all domain.  timeout_exceeded:  (unknown) These emails belong to a mail server that is responding extremely slow. Most of the time, these emails will end up being invalid.  unroutable_ip_address: (invalid) These emails domains point to an un-routable IP address, these are marked invalid.  disposable:  (do_not_mail) These are temporary emails created for the sole purpose to sign up to websites without giving their real email address. These emails are short lived from 15 minutes to around 6 months. There is only 2 values (True and False). If you have valid emails with this flag set to TRUE, you shouldn't email them.  toxic:  (do_not_mail) These email addresses are known to be abuse, spam, or bot created emails. If you have valid emails with this flag set to TRUE, you shouldn't email them.
     *
     * @return self
     */
    public function setSubStatus($sub_status)
    {
        if (is_null($sub_status)) {
            throw new \InvalidArgumentException('non-nullable sub_status cannot be null');
        }
        $allowedValues = $this->getSubStatusAllowableValues();
        if (!in_array($sub_status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'sub_status', must be one of '%s'",
                    $sub_status,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['sub_status'] = $sub_status;

        return $this;
    }

    /**
     * Gets free_email
     *
     * @return bool|null
     */
    public function getFreeEmail()
    {
        return $this->container['free_email'];
    }

    /**
     * Sets free_email
     *
     * @param bool|null $free_email True if the email address comes from a free email service provider.
     *
     * @return self
     */
    public function setFreeEmail($free_email)
    {
        if (is_null($free_email)) {
            throw new \InvalidArgumentException('non-nullable free_email cannot be null');
        }
        $this->container['free_email'] = $free_email;

        return $this;
    }

    /**
     * Gets domain
     *
     * @return string|null
     */
    public function getDomain()
    {
        return $this->container['domain'];
    }

    /**
     * Sets domain
     *
     * @param string|null $domain The portion of the email address after the \"@\" symbol.
     *
     * @return self
     */
    public function setDomain($domain)
    {
        if (is_null($domain)) {
            throw new \InvalidArgumentException('non-nullable domain cannot be null');
        }
        $this->container['domain'] = $domain;

        return $this;
    }

    /**
     * Gets domain_age_days
     *
     * @return int|null
     */
    public function getDomainAgeDays()
    {
        return $this->container['domain_age_days'];
    }

    /**
     * Sets domain_age_days
     *
     * @param int|null $domain_age_days Age of the email domain in days or [null].
     *
     * @return self
     */
    public function setDomainAgeDays($domain_age_days)
    {
        if (is_null($domain_age_days)) {
            array_push($this->openAPINullablesSetToNull, 'domain_age_days');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('domain_age_days', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['domain_age_days'] = $domain_age_days;

        return $this;
    }

    /**
     * Gets smtp_provider
     *
     * @return string|null
     */
    public function getSmtpProvider()
    {
        return $this->container['smtp_provider'];
    }

    /**
     * Sets smtp_provider
     *
     * @param string|null $smtp_provider The SMTP Provider of the email or [null].
     *
     * @return self
     */
    public function setSmtpProvider($smtp_provider)
    {
        if (is_null($smtp_provider)) {
            array_push($this->openAPINullablesSetToNull, 'smtp_provider');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('smtp_provider', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['smtp_provider'] = $smtp_provider;

        return $this;
    }

    /**
     * Gets mx_found
     *
     * @return bool|null
     */
    public function getMxFound()
    {
        return $this->container['mx_found'];
    }

    /**
     * Sets mx_found
     *
     * @param bool|null $mx_found True if the domain have an MX record.
     *
     * @return self
     */
    public function setMxFound($mx_found)
    {
        if (is_null($mx_found)) {
            throw new \InvalidArgumentException('non-nullable mx_found cannot be null');
        }
        $this->container['mx_found'] = $mx_found;

        return $this;
    }

    /**
     * Gets mx_record
     *
     * @return string|null
     */
    public function getMxRecord()
    {
        return $this->container['mx_record'];
    }

    /**
     * Sets mx_record
     *
     * @param string|null $mx_record The preferred MX record of the domain
     *
     * @return self
     */
    public function setMxRecord($mx_record)
    {
        if (is_null($mx_record)) {
            throw new \InvalidArgumentException('non-nullable mx_record cannot be null');
        }
        $this->container['mx_record'] = $mx_record;

        return $this;
    }

    /**
     * Gets did_you_mean
     *
     * @return string|null
     */
    public function getDidYouMean()
    {
        return $this->container['did_you_mean'];
    }

    /**
     * Sets did_you_mean
     *
     * @param string|null $did_you_mean Suggestive Fix for an email typo
     *
     * @return self
     */
    public function setDidYouMean($did_you_mean)
    {
        if (is_null($did_you_mean)) {
            throw new \InvalidArgumentException('non-nullable did_you_mean cannot be null');
        }
        $this->container['did_you_mean'] = $did_you_mean;

        return $this;
    }

    /**
     * Gets account
     *
     * @return string|null
     */
    public function getAccount()
    {
        return $this->container['account'];
    }

    /**
     * Sets account
     *
     * @param string|null $account The portion of the email address before the \"@\" symbol.
     *
     * @return self
     */
    public function setAccount($account)
    {
        if (is_null($account)) {
            throw new \InvalidArgumentException('non-nullable account cannot be null');
        }
        $this->container['account'] = $account;

        return $this;
    }

    /**
     * Gets firstname
     *
     * @return string|null
     */
    public function getFirstname()
    {
        return $this->container['firstname'];
    }

    /**
     * Sets firstname
     *
     * @param string|null $firstname The first name of the owner of the email when available or [null].
     *
     * @return self
     */
    public function setFirstname($firstname)
    {
        if (is_null($firstname)) {
            array_push($this->openAPINullablesSetToNull, 'firstname');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('firstname', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['firstname'] = $firstname;

        return $this;
    }

    /**
     * Gets lastname
     *
     * @return string|null
     */
    public function getLastname()
    {
        return $this->container['lastname'];
    }

    /**
     * Sets lastname
     *
     * @param string|null $lastname The last name of the owner of the email when available or [null].
     *
     * @return self
     */
    public function setLastname($lastname)
    {
        if (is_null($lastname)) {
            array_push($this->openAPINullablesSetToNull, 'lastname');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('lastname', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['lastname'] = $lastname;

        return $this;
    }

    /**
     * Gets gender
     *
     * @return string|null
     */
    public function getGender()
    {
        return $this->container['gender'];
    }

    /**
     * Sets gender
     *
     * @param string|null $gender The gender of the owner of the email when available or [null].
     *
     * @return self
     */
    public function setGender($gender)
    {
        if (is_null($gender)) {
            array_push($this->openAPINullablesSetToNull, 'gender');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('gender', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['gender'] = $gender;

        return $this;
    }

    /**
     * Gets country
     *
     * @return string|null
     */
    public function getCountry()
    {
        return $this->container['country'];
    }

    /**
     * Sets country
     *
     * @param string|null $country The country of the IP passed in or [null]
     *
     * @return self
     */
    public function setCountry($country)
    {
        if (is_null($country)) {
            array_push($this->openAPINullablesSetToNull, 'country');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('country', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['country'] = $country;

        return $this;
    }

    /**
     * Gets region
     *
     * @return string|null
     */
    public function getRegion()
    {
        return $this->container['region'];
    }

    /**
     * Sets region
     *
     * @param string|null $region The region/state of the IP passed in or [null]
     *
     * @return self
     */
    public function setRegion($region)
    {
        if (is_null($region)) {
            array_push($this->openAPINullablesSetToNull, 'region');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('region', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['region'] = $region;

        return $this;
    }

    /**
     * Gets city
     *
     * @return string|null
     */
    public function getCity()
    {
        return $this->container['city'];
    }

    /**
     * Sets city
     *
     * @param string|null $city The city of the IP passed in or [null]
     *
     * @return self
     */
    public function setCity($city)
    {
        if (is_null($city)) {
            array_push($this->openAPINullablesSetToNull, 'city');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('city', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['city'] = $city;

        return $this;
    }

    /**
     * Gets zipcode
     *
     * @return int|null
     */
    public function getZipcode()
    {
        return $this->container['zipcode'];
    }

    /**
     * Sets zipcode
     *
     * @param int|null $zipcode The zipcode of the IP passed in or [null]
     *
     * @return self
     */
    public function setZipcode($zipcode)
    {
        if (is_null($zipcode)) {
            array_push($this->openAPINullablesSetToNull, 'zipcode');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('zipcode', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['zipcode'] = $zipcode;

        return $this;
    }

    /**
     * Gets processed_at
     *
     * @return string|null
     */
    public function getProcessedAt()
    {
        return $this->container['processed_at'];
    }

    /**
     * Sets processed_at
     *
     * @param string|null $processed_at The date time the email was validated.
     *
     * @return self
     */
    public function setProcessedAt($processed_at)
    {
        if (is_null($processed_at)) {
            throw new \InvalidArgumentException('non-nullable processed_at cannot be null');
        }

        if ((!preg_match("/(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})/", ObjectSerializer::toString($processed_at)))) {
            throw new \InvalidArgumentException("invalid value for \$processed_at when calling EmailValidatorMailDetails., must conform to the pattern /(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})/.");
        }

        $this->container['processed_at'] = $processed_at;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


